diff --git a/README.md b/README.md
index 130ceb2..353fab0 100644
--- a/README.md
+++ b/README.md
@@ -56,12 +56,7 @@ Before start:
 * Libraries and Steam are present on the folders described by `INSTALL.md`.
 
 Procedure:
-1. Start a `roscore`
-2. Launch the SteamVR's `vrserver` by launching the file: `roslaunch vive_ros server_vr.launch`
-3. Launch the node: `roslaunch vive_ros vive.launch`
-4. To close the node you can `Ctrl+C`. To close the vr server you have to kill the process. For convenience: `rosrun vive_ros close_servervr.sh`
 
-Update
-1. Hardware Safety code added in order to shutdown of hardware. This will prevent hardware from any damage caused due to abrupt shutdown.
-
-2. It has code updated for publishing HTC Vive Component (HTC Vive Headset and 2 HTC Controllers) data.
+1. Launch the SteamVR's `vrserver` by launching the file: `roslaunch vive_ros server_vr.launch`
+2. Launch the node: `roslaunch vive_ros vive.launch`
+3. To close the node you can `Ctrl+C`. To close the vr server you have to kill the process. For convenience: `rosrun vive_ros close_servervr.sh`
diff --git a/launch/vive.launch b/launch/vive.launch
index 1b62b44..d25d443 100644
--- a/launch/vive.launch
+++ b/launch/vive.launch
@@ -4,7 +4,6 @@
   <rosparam param="/vive/world_offset">[0, 0, 2.265]</rosparam>
   <rosparam param="/vive/world_yaw">0.0</rosparam>
 
-  <node name="vive_node" pkg="vive_ros" type="vive_node" launch-prefix="$(find vive_ros)/scripts/find_steam_runtime.sh" output="screen" required="true"/>
+  <node name="vive_node" pkg="vive_ros" type="vive_node" launch-prefix="$(env HOME)/.steam/steam/ubuntu12_32/steam-runtime/run.sh" output="screen" required="true"/>
 
 </launch>
-
diff --git a/scripts/find_steam_runtime.sh b/scripts/find_steam_runtime.sh
deleted file mode 100755
index 173d060..0000000
--- a/scripts/find_steam_runtime.sh
+++ /dev/null
@@ -1,17 +0,0 @@
-#!/bin/bash
-
-candidate_1=${HOME}/.steam/ubuntu12_32/steam-runtime/run.sh
-candidate_2=${HOME}/.steam/steam/ubuntu12_32/steam-runtime/run.sh
-
-if [ -e $candidate_1 ]; then
-    echo "runtime setup script found on $candidate_1"
-    exec $candidate_1 "$@"
-    
-elif [ -e $candidate_2 ]; then
-    echo "runtime setup script found on $candidate_2"
-    exec $candidate_2 "$@"
-
-else
-    echo "\e[31m [ERROR] steam runtime setup script not found !! \e[m"
-    exit 1
-fi
diff --git a/src/vive_node.cpp b/src/vive_node.cpp
index 63f192b..3b7f303 100644
--- a/src/vive_node.cpp
+++ b/src/vive_node.cpp
@@ -1,28 +1,17 @@
 #include <cmath>
 #include <ros/ros.h>
-#include <signal.h>
 #include <tf/transform_broadcaster.h>
 #include <tf/transform_listener.h>
 #include <sensor_msgs/Joy.h>
 #include <sensor_msgs/JoyFeedback.h>
 #include <std_srvs/Empty.h>
-#include <iostream>
 #include "vive_ros/vr_interface.h"
-#include <geometry_msgs/TwistStamped.h>
-
-using namespace std;
 
 void handleDebugMessages(const std::string &msg) {ROS_DEBUG(" [VIVE] %s",msg.c_str());}
 void handleInfoMessages(const std::string &msg) {ROS_INFO(" [VIVE] %s",msg.c_str());}
 void handleErrorMessages(const std::string &msg) {ROS_ERROR(" [VIVE] %s",msg.c_str());}
-void mySigintHandler(int sig){
-// Do some custom action.
-// For example, publish a stop message to some other nodes.
-// All the default sigint handler does is call shutdown()
-ros::shutdown();
-}
 
-//#define USE_IMAGE
+#define USE_IMAGE
 
 #define USE_OPENGL
 //#define USE_VULKAN
@@ -44,7 +33,7 @@ class CMainApplicationMod : public CMainApplication{
     , hmd_fov(110*M_PI/180) {
 //      m_bShowCubes = false;
       for(int i=0;i<LR;i++){
-        cam_f[i][X] = cam_f[i][Y] = 600;
+        cam_f[i][X] = cam_f[i][Y] = 750;
       }
       RenderFrame_hz_count = 0;
     };
@@ -58,10 +47,10 @@ class CMainApplicationMod : public CMainApplication{
     int RenderFrame_hz_count;
 
     void InitTextures(){
-      ros_img[L] = cv::Mat(cv::Size(640, 480), CV_8UC3, CV_RGB(255,0,0));
-      ros_img[R] = cv::Mat(cv::Size(640, 480), CV_8UC3, CV_RGB(0,255,0));
-      hmd_panel_img[L] = cv::Mat(cv::Size(m_nRenderWidth, m_nRenderHeight), CV_8UC3, CV_RGB(100,100,100));
-      hmd_panel_img[R] = cv::Mat(cv::Size(m_nRenderWidth, m_nRenderHeight), CV_8UC3, CV_RGB(100,100,100));
+      ros_img[L] = cv::Mat(cv::Size(m_nRenderWidth, m_nRenderHeight), CV_8UC3, CV_RGB(255, 255, 255));
+      ros_img[R] = cv::Mat(cv::Size(m_nRenderWidth, m_nRenderHeight), CV_8UC3, CV_RGB(255, 255, 255));
+      hmd_panel_img[L] = cv::Mat(cv::Size(m_nRenderWidth, m_nRenderHeight), CV_8UC3, CV_RGB(255, 255, 255));
+      hmd_panel_img[R] = cv::Mat(cv::Size(m_nRenderWidth, m_nRenderHeight), CV_8UC3, CV_RGB(255, 255, 255));
       for ( int i = 0; i < vr::k_unMaxTrackedDeviceCount; i++){
         if(m_pHMD->GetTrackedDeviceClass(i) == vr::TrackedDeviceClass_HMD){
           m_pHMD->GetStringTrackedDeviceProperty( i, vr::Prop_ScreenshotHorizontalFieldOfViewDegrees_Float, (char *)&hmd_fov_h, sizeof(float), NULL );
@@ -92,7 +81,7 @@ class CMainApplicationMod : public CMainApplication{
       if ( m_iTrackedControllerCount != m_iTrackedControllerCount_Last || m_iValidPoseCount != m_iValidPoseCount_Last ){
         m_iValidPoseCount_Last = m_iValidPoseCount;
         m_iTrackedControllerCount_Last = m_iTrackedControllerCount;
-        dprintf( "PoseCount:%d(%s) Controllers:%d\n", m_iValidPoseCount, m_strPoseClasses.c_str(), m_iTrackedControllerCount );
+        //dprint( "PoseCount:%d(%s) Controllers:%d\n", m_iValidPoseCount, m_strPoseClasses.c_str(), m_iTrackedControllerCount );
       }
       UpdateHMDMatrixPose();
       ROS_INFO_THROTTLE(3.0,"RenderFrame() @ %d [fps]", [](int& cin, int dur){int ans = cin; cin=0; return ans/dur;}(RenderFrame_hz_count, 3));
@@ -103,7 +92,7 @@ class CMainApplicationMod : public CMainApplication{
     cv::Mat hmd_panel_img[LR];
     cv::Mat ros_img_resized[LR];
     void processROSStereoImage(cv::Mat (&in)[LR], cv::Mat (&out)[LR]){
-      const double hmd_eye2panel_z[XY] = { (double)out[L].rows/2/tan(hmd_fov/2), (double)out[L].rows/2/tan(hmd_fov/2) };
+      const double hmd_eye2panel_z[XY] = { (double)out[L].cols/2/tan(hmd_fov/2), (double)out[L].rows/2/tan(hmd_fov/2) };
       const double cam_pic_size[LR][XY] = { { (double)in[L].cols, (double)in[L].rows }, { (double)in[R].cols, (double)in[R].rows } };
       double cam_fov[LR][XY];
       int cam_pic_size_on_hmd[LR][XY];
@@ -112,7 +101,7 @@ class CMainApplicationMod : public CMainApplication{
         ROS_INFO_THROTTLE(3.0,"Process ROS image[%d] (%dx%d) with fov (%dx%d) to (%dx%d)", i, in[i].cols, in[i].rows, (int)cam_f[i][X], (int)cam_f[i][Y], out[i].cols, out[i].rows);
         for(int j=0;j<XY;j++){
           cam_fov[i][j] = 2 * atan( cam_pic_size[i][j]/2 / cam_f[i][j] );
-          cam_pic_size_on_hmd[i][j] = (int)( hmd_eye2panel_z[X] * 2 * tan(cam_fov[i][j]/2) );
+          cam_pic_size_on_hmd[i][j] = (int)( hmd_eye2panel_z[j] * 2 * tan(cam_fov[i][j]/2) );
         }
         cv::resize(in[i], ros_img_resized[i], cv::Size(cam_pic_size_on_hmd[i][X], cam_pic_size_on_hmd[i][Y]));
         cv::flip(ros_img_resized[i], ros_img_resized[i], 0);
@@ -313,7 +302,7 @@ class CMainApplicationMod : public CMainApplication
       if ( m_iTrackedControllerCount != m_iTrackedControllerCount_Last || m_iValidPoseCount != m_iValidPoseCount_Last ) {
         m_iValidPoseCount_Last = m_iValidPoseCount;
         m_iTrackedControllerCount_Last = m_iTrackedControllerCount;
-        dprintf( "PoseCount:%d(%s) Controllers:%d\n", m_iValidPoseCount, m_strPoseClasses.c_str(), m_iTrackedControllerCount );
+        //dprintf( "PoseCount:%d(%s) Controllers:%d\n", m_iValidPoseCount, m_strPoseClasses.c_str(), m_iTrackedControllerCount );
       }
       UpdateHMDMatrixPose();
       m_nFrameIndex = ( m_nFrameIndex + 1 ) % m_swapchainImages.size();
@@ -455,9 +444,6 @@ class VIVEnode
     tf::TransformBroadcaster tf_broadcaster_;
     tf::TransformListener tf_listener_;
     ros::ServiceServer set_origin_server_;
-    ros::Publisher twist0_pub_;
-    ros::Publisher twist1_pub_;
-    ros::Publisher twist2_pub_;
     std::map<std::string, ros::Publisher> button_states_pubs_map;
     ros::Subscriber feedback_sub_;
 
@@ -465,7 +451,7 @@ class VIVEnode
 
 VIVEnode::VIVEnode(int rate)
   : loop_rate_(rate)
-  , nh_()
+  , nh_("~")
   , tf_broadcaster_()
   , tf_listener_()
   , vr_()
@@ -476,17 +462,14 @@ VIVEnode::VIVEnode(int rate)
   nh_.getParam("/vive/world_yaw", world_yaw_);
   ROS_INFO(" [VIVE] World offset: [%2.3f , %2.3f, %2.3f] %2.3f", world_offset_[0], world_offset_[1], world_offset_[2], world_yaw_);
   set_origin_server_ = nh_.advertiseService("/vive/set_origin", &VIVEnode::setOriginCB, this);
-  twist0_pub_ = nh_.advertise<geometry_msgs::TwistStamped>("/vive/twist0", 10);
-  twist1_pub_ = nh_.advertise<geometry_msgs::TwistStamped>("/vive/twist1", 10);
-  twist2_pub_ = nh_.advertise<geometry_msgs::TwistStamped>("/vive/twist2", 10);
   feedback_sub_ = nh_.subscribe("/vive/set_feedback", 10, &VIVEnode::set_feedback, this);
 
 #ifdef USE_IMAGE
   image_transport::ImageTransport it(nh_);
-  sub_L = it.subscribe("/image_left", 1, &VIVEnode::imageCb_L, this);
-  sub_R = it.subscribe("/image_right", 1, &VIVEnode::imageCb_R, this);
-  sub_i_L = nh_.subscribe("/camera_info_left", 1, &VIVEnode::infoCb_L, this);
-  sub_i_R = nh_.subscribe("/camera_info_right", 1, &VIVEnode::infoCb_R, this);
+  sub_L = it.subscribe("image_left", 1, &VIVEnode::imageCb_L, this);
+  sub_R = it.subscribe("image_right", 1, &VIVEnode::imageCb_R, this);
+  sub_i_L = nh_.subscribe("camera_info_left", 1, &VIVEnode::infoCb_L, this);
+  sub_i_R = nh_.subscribe("camera_info_right", 1, &VIVEnode::infoCb_R, this);
   pMainApplication = new CMainApplicationMod( 0, NULL );
   if (!pMainApplication->BInit()){
     pMainApplication->Shutdown();
@@ -495,6 +478,7 @@ VIVEnode::VIVEnode(int rate)
   pMainApplication->vr_p = &(vr_);
   pMainApplication->InitTextures();
 #endif
+
   return;
 }
 
@@ -506,7 +490,6 @@ VIVEnode::~VIVEnode()
 bool VIVEnode::Init()
 {
   //  Set logging functions
-  
   vr_.setDebugMsgCallback(handleDebugMessages);
   vr_.setInfoMsgCallback(handleInfoMessages);
   vr_.setErrorMsgCallback(handleErrorMessages);
@@ -667,69 +650,6 @@ void VIVEnode::Run()
 
     tf_broadcaster_.sendTransform(tf::StampedTransform(tf_world, ros::Time::now(), "world", "world_vive"));
 
-    // Publish twist messages for controller1 and controller2
-    double lin_vel[3], ang_vel[3];
-    if (vr_.GetDeviceVel(0, lin_vel, ang_vel))
-    {
-        geometry_msgs::Twist twist_msg;
-        twist_msg.linear.x = lin_vel[0];
-        twist_msg.linear.y = lin_vel[1];
-        twist_msg.linear.z = lin_vel[2];
-        twist_msg.angular.x = ang_vel[0];
-        twist_msg.angular.y = ang_vel[1];
-        twist_msg.angular.z = ang_vel[2];
-
-        geometry_msgs::TwistStamped twist_msg_stamped;
-        twist_msg_stamped.header.stamp = ros::Time::now();
-        twist_msg_stamped.header.frame_id = "world_vive";
-        twist_msg_stamped.twist = twist_msg;
-
-        twist0_pub_.publish(twist_msg_stamped);
-     
-        // std::cout<<"HMD:";
-        // std::cout<<twist_msg_stamped;
-    }
-    if (vr_.GetDeviceVel(1, lin_vel, ang_vel))
-    {
-        geometry_msgs::Twist twist_msg;
-        twist_msg.linear.x = lin_vel[0];
-        twist_msg.linear.y = lin_vel[1];
-        twist_msg.linear.z = lin_vel[2];
-        twist_msg.angular.x = ang_vel[0];
-        twist_msg.angular.y = ang_vel[1];
-        twist_msg.angular.z = ang_vel[2];
-
-        geometry_msgs::TwistStamped twist_msg_stamped;
-        twist_msg_stamped.header.stamp = ros::Time::now();
-        twist_msg_stamped.header.frame_id = "world_vive";
-        twist_msg_stamped.twist = twist_msg;
-
-        twist1_pub_.publish(twist_msg_stamped);
-     
-        // std::cout<<"Controller 1:";
-        // std::cout<<twist_msg_stamped;
-    }
-    if (vr_.GetDeviceVel(2, lin_vel, ang_vel))
-    {
-        geometry_msgs::Twist twist_msg;
-        twist_msg.linear.x = lin_vel[0];
-        twist_msg.linear.y = lin_vel[1];
-        twist_msg.linear.z = lin_vel[2];
-        twist_msg.angular.x = ang_vel[0];
-        twist_msg.angular.y = ang_vel[1];
-        twist_msg.angular.z = ang_vel[2];
-
-        geometry_msgs::TwistStamped twist_msg_stamped;
-        twist_msg_stamped.header.stamp = ros::Time::now();
-        twist_msg_stamped.header.frame_id = "world_vive";
-        twist_msg_stamped.twist = twist_msg;
-
-        twist2_pub_.publish(twist_msg_stamped);
-     
-        // std::cout<<"Controller 2:";
-        // std::cout<<twist_msg_stamped;
-    }
-   
 #ifdef USE_IMAGE
     pMainApplication->HandleInput();
     pMainApplication->RenderFrame();
@@ -786,22 +706,20 @@ void VIVEnode::infoCb_R(const sensor_msgs::CameraInfoConstPtr& msg){
 
 // Main
 int main(int argc, char** argv){
-  signal(SIGINT, mySigintHandler);
   ros::init(argc, argv, "vive_node");
 
 #ifdef USE_IMAGE
   VIVEnode nodeApp(90); // VIVE display max fps
 #else
-  VIVEnode nodeApp(30);
+  VIVEnode nodeApp(1000);
 #endif
   if (!nodeApp.Init()){
     nodeApp.Shutdown();
     return 1;
   }
-  
+
   nodeApp.Run();
   nodeApp.Shutdown();
-  
 
   return 0;
 };
diff --git a/src/vr_interface.cpp b/src/vr_interface.cpp
index a46b3cb..26e63d6 100644
--- a/src/vr_interface.cpp
+++ b/src/vr_interface.cpp
@@ -54,7 +54,8 @@ bool VRInterface::Init()
   // Loading the SteamVR Runtime
   vr::EVRInitError eError = vr::VRInitError_None;
   
-  pHMD_ = vr::VR_Init( &eError, vr::VRApplication_Background );
+  // pHMD_ = vr::VR_Init( &eError, vr::VRApplication_Background );
+  pHMD_ = vr::VR_Init( &eError, vr::VRApplication_Scene );
 
   if (eError != vr::VRInitError_None)
   {
